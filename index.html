<html>

<head>
  <title>DBD</title>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
</head>
<style>
  * {
    margin: 0;
    padding: 0;
    outline: 0;
  }

  html,
  body {
    width: 100%;
    background-color: rgba(64, 64, 64, 1);
  }

  .hcenter {
    position: absolute;
    margin: 0;
    left: 50%;
    transform: translateX(-50%);
  }
</style>
<body>
  <div>
    <div id="main" class="hcenter" style="width: 1200px;">

    </div>
  </div>
  <div id="canvasWrap">
  </div>
</body>
<script type="text/javascript">
let language = localStorage.getItem("language") || "zh-Hans";
localStorage.setItem("language", language);

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        let temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
}

function perkOnEnter(e) {
    updateCanvas(e.target.dataset.perk);
}

function updateCanvas(perkCode) {
    let item = localStorage.getItem(perkCode)
    let owner = perkCode + ".owner";
    let ownerCode = localStorage.getItem(owner);
    let rarity = localStorage.getItem(perkCode + ".rarity");
    if (!item) {
        ownerCode = "unrevealed.owner";
        item = localStorage.getItem("unrevealed");
        rarity = [0, 0, 0];
    } else {
        rarity = JSON.parse(rarity);
    }
    canvasTitle.innerHTML = JSON.parse(item)[language];
    bgColor = JSON.parse(localStorage.getItem("raritycolor"))[rarity[1]];
    let ownerData = localStorage.getItem(ownerCode);
    let ownerText = "";
    if (ownerData) {
        canvasDesc.innerHTML = (JSON.parse(localStorage.getItem("rarity"))[rarity[1]]) + " - " + JSON.parse(localStorage.getItem(ownerCode))[language] + " - 技能";
    } else {
        canvasDesc.innerHTML = "" + (JSON.parse(localStorage.getItem("rarity"))[rarity[1]]) + " - 技能";
    }
}
let list = ["unrevealed", "unrevealed.owner", "rarity", "raritycolor"];
list.forEach(element => {
    fetch("https://www.sgkoishi.app/dbddata/static/" + element + ".json").then(r => r.json()).then(r => {
        localStorage.setItem(element, JSON.stringify(r));
    })
});

function randomArray(min, max, length, isint) {
    return isint ? Array.from({
            length: length
        }, () => Math.floor(Math.random() * (max - min) + min)) :
        Array.from({
            length: length
        }, () => Math.random() * (max - min) + min);
}
let expWidth = 1200;
let expHeight = 1000;
let scene = new THREE.Scene();
let camera = new THREE.OrthographicCamera(0, 10, 0, 10, -5, 5);
let camera2 = new THREE.OrthographicCamera(10, 20, 1.5, -1.5, -2, 2);
let renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
});
renderer.setClearColor("rgb(255, 0, 0)", 0);
renderer.setSize(expWidth, expHeight);
document.getElementById("main").appendChild(renderer.domElement);
let mouse = new THREE.Vector2(-100, -100);
let floating = new THREE.Vector2(-600, -600);
let mouseDown = false;
let pureMouse = new THREE.Vector2(-100, -100);
let inCMouse = new THREE.Vector2(-100, -100);
let loader = new THREE.TextureLoader();
let perkImg = loader.load("https://www.sgkoishi.app/dbddata/static/perks.png");
let materialPerk = new THREE.MeshLambertMaterial({
    map: perkImg,
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest: false
});
let geometry = new THREE.PlaneGeometry(1, 1);
let blackBg = new THREE.Mesh(geometry);
blackBg.material.color.set(0);
blackBg.position.set(15, 0, 0);
blackBg.scale.set(10, 3, 1);
scene.add(blackBg);
let materialSmoke = new THREE.MeshLambertMaterial({
    map: loader.load("https://www.sgkoishi.app/dbd/smoke.png"),
    transparent: true,
    depthWrite: false,
    depthTest: false
});
materialSmoke.color.set("rgb(90, 40, 110)");
let meshSmokes = [];
for (let i = 0; i < 60; i++) {
    let meshSmoke = new THREE.Mesh(geometry, materialSmoke.clone());
    meshSmoke.userVX = (Math.random() * 8 + 2) / 240;
    meshSmoke.userBX = (Math.random() * 5) + 16;
    meshSmoke.userY = Math.random() * 3 - 1.5;
    meshSmoke.userRS = ((Math.random() * 2 - 1) * Math.PI) / 360;
    meshSmoke.position.set(Math.random() * 12 + 6, meshSmoke.userY, 0);
    meshSmoke.scale.set(4, 4, 4);
    meshSmokes.push(meshSmoke);
    scene.add(meshSmoke);
}
function makeText(t, font, width, height, textx, texty, fillstyle) {
    let bitmap = document.createElement('canvas');
    let g = bitmap.getContext('2d');
    bitmap.width = width;
    bitmap.height = height;
    g.font = font;
    g.fillStyle = fillstyle;
    g.fillText(t, textx, texty);
    let texture = new THREE.Texture(bitmap)
    texture.needsUpdate = true;
    return texture;
}
let textBg = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
    map: makeText("把最好的留到最后","Bold 72px Arial", 84*9, 84, 0, 70, "white"),
    transparent: true
}));
//blackBg.material.color.set(0);
textBg.position.set(15, 0, 0);
textBg.scale.set(9, 99 ** 99 == Math.pow(99, 99) ? 1 : -1, 1);
scene.add(textBg);
// https://www.sgkoishi.app/img/koishi.png
// https://www.sgkoishi.app/dbddata/static/perks.png
// https://www.sgkoishi.app/dbd/smoke.png

let meshPerks = [];
fetch("https://www.sgkoishi.app/dbddata/static/killerperks.json").then(r => r.json()).then(r => {
    let perksShuffled = shuffleArray(r);
    for (let i = 0; i < perksShuffled.length; i++)
    {
        let meshPerk = new THREE.Mesh(geometry, materialPerk);
        meshPerk.position.set(0.5 + i % 10, 2.5 + parseInt(i / 10), 0);
        meshPerk.rotation.y = Math.PI;
        meshPerk.scale.y = -1;
        meshPerk.userPerkCode = perksShuffled[i];
        meshPerks.push(meshPerk);
        scene.add(meshPerk);
    }
});
let light = new THREE.AmbientLight(0xffffff, 2); // soft white light
scene.add(light);
let now = Date.now();

function animate() {
    requestAnimationFrame(animate);
    if (mouseDown) {
        let xMatch = Math.abs(mouse.x % 1 - 0.5);
        let yMatch = Math.abs(mouse.y % 1 - 0.5);
        if (xMatch + yMatch < 0.4 && Math.abs(xMatch - yMatch) < 0.4)
        {
            let i = Math.round(Math.round(mouse.x - 0.5) + Math.round(mouse.y - 2.5) * 10);
            if (!meshPerks[i].userFetch) {
                meshPerks[i].userFetch = true;
                let key = meshPerks[i].userPerkCode;
                fetch("https://www.sgkoishi.app/dbddata/" + key + "/owner.json").then(r => {
                    return r.json();
                }).then(r => {
                    localStorage.setItem(key + ".owner", r.owner);
                    let ownerCode = r.owner;
                    if (!localStorage.getItem(ownerCode)) {
                        fetch("https://www.sgkoishi.app/dbddata/" + ownerCode + "/data.json").then(r => {
                            return r.json();
                        }).then(r => {
                            localStorage.setItem(ownerCode, JSON.stringify(r));
                        });
                    }
                }, e => {});
                fetch("https://www.sgkoishi.app/dbddata/" + key + "/rarity.json").then(r => {
                    return r.json();
                }).then(r => {
                    localStorage.setItem(key + ".rarity", JSON.stringify(r));
                });
                fetch("https://www.sgkoishi.app/dbddata/" + key + "/data.json").then(r => {
                    return r.json();
                }).then(r => {
                    localStorage.setItem(key, JSON.stringify(r));
                    meshPerks[i].shouldRotate = true;
                    meshPerks[i].newTexture = loader.load("https://www.sgkoishi.app/dbddata/" + key + "/icon.png");
                }, (r) => {
                    console.log(r);
                });
            }
        }
    }
    for (let i = 0; i < meshPerks.length; i++) {
        let meshPerk = meshPerks[i];
        if (meshPerk.shouldRotate) {
            if (meshPerk.rotation.y < Math.PI * 1.5) {
                meshPerk.rotation.y += Math.PI / 120;
            } else if (!meshPerk.userDataInit) {
                meshPerk.userDataInit = true;
                meshPerk.material = meshPerk.material.clone();
                meshPerk.material.color.set(0x5A413E);
                meshPerk.material = new THREE.ShaderMaterial({
    vertexShader: `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`,
    fragmentShader: `
uniform sampler2D textureA;
uniform sampler2D textureB;
uniform vec3 color;
varying vec2 vUv;
void main() {
    vec3 c;
    vec2 scaledvuv = vUv;
    scaledvuv -= vec2(0.5);
    scaledvuv = mat2(1.8, 0.0, 0.0, 1.8) * scaledvuv;
    scaledvuv += vec2(0.5);
    scaledvuv.x -= 0.025;
    vec4 Ca = texture2D(textureA, vUv);
    vec4 Cb = texture2D(textureB, scaledvuv);
    c = Cb.rgb * Cb.a + Ca.rgb * Ca.a * (1.0 - Cb.a);
    gl_FragColor= vec4(c, 1.0);
    if (Ca.a < 0.5) 
    {
        gl_FragColor.a = 0.0;
    }
}`,
    uniforms: {
        textureA: { type: "t", value: perkImg },
        textureB: { type: "t", value: meshPerk.newTexture }
    },
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest: false
});
            } else if (meshPerk.rotation.y < Math.PI * 2) {
                meshPerk.rotation.y += Math.PI / 120;
            }
        }
    }
    for (let i = 0; i < meshSmokes.length; i++) {
        meshSmokes[i].position.x += meshSmokes[i].userVX;
        if (meshSmokes[i].position.x > meshSmokes[i].userBX) {
            meshSmokes[i].position.x = 8;
            meshSmokes[i].material.opacity = 1;
        } else {
            meshSmokes[i].material.opacity = 1 - (meshSmokes[i].position.x - 9) / (meshSmokes[i].userBX - 8);
        }
        meshSmokes[i].rotation.z += meshSmokes[i].userRS;
    }
    renderer.setViewport(0, 0, expWidth, expWidth);
    renderer.setScissor(0, 0, expWidth, expHeight);
    renderer.setScissorTest(true);
    renderer.render(scene, camera);
    renderer.autoClear = false;
    renderer.setViewport(floating.x, floating.y, 500, 150);
    renderer.setScissor(floating.x, floating.y, 500, 150);
    renderer.setScissorTest(true);
    renderer.render(scene, camera2);
    renderer.autoClear = true;
    renderer.setClearColor("rgb(64, 64, 64)", 1);
}

function updateMouse() {
    mouse.x = ((pureMouse.x - document.getElementById("main").getBoundingClientRect().x) / Math.min(expWidth, window.innerWidth)) * 10;
    mouse.y = ((pureMouse.y - document.getElementById("main").getBoundingClientRect().y) / Math.min(expHeight, window.innerHeight)) * 8.35 + 1.65;
    floating.x = pureMouse.x - document.getElementById("main").getBoundingClientRect().x;
    if (floating.x < 0) floating.x = 0;
    else if (floating.x > expWidth) floating.x = 700;
    else if (floating.x + 500 > expWidth) floating.x -= 500;
    floating.y = expHeight - pureMouse.y + document.getElementById("main").getBoundingClientRect().y - 150;
    if (floating.y < 0) floating.y += 150;
}
window.addEventListener('mousemove', (event) => {
    pureMouse.x = event.clientX
    pureMouse.y = event.clientY;
    updateMouse();
}, false);
window.addEventListener('scroll', updateMouse, false);
window.addEventListener("mousedown", () => mouseDown = true);
window.addEventListener("mouseup", () => mouseDown = false);
animate();
</script>

</html>