<html>

<head>
  <title>DBD</title>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
</head>
<style>
  * {
    margin: 0;
    padding: 0;
    outline: 0;
  }

  html,
  body {
    width: 100%;
    background-color: rgba(64, 64, 64, 1);
  }

  .hcenter {
    position: absolute;
    margin: 0;
    left: 50%;
    transform: translateX(-50%);
  }

  .fixb {
    position: fixed;
    bottom: 0;
	text-align: center;
  }
</style>
<body>
  <div>
    <div id="main" class="hcenter" style="width: 1200px;">

    </div>
  </div>
  <div class="hcenter fixb"><h2 style="color: white;">逃生者：<a href="?q=survivorperks" style="color: green;">技能</a> | <a href="" style="color: white;">物品</a> | <a href="" style="color: white;">附加品</a> | <a href="" style="color: white;">祭品</a></br>杀手：<a href="?q=killerperks" style="color: green;">技能</a> | <a href="" style="color: white;">能力</a> | <a href="" style="color: white;">附加品</a> | <a href="" style="color: white;">祭品</a></h2>
  </div>
</body>
<script type="text/javascript">
let language = localStorage.getItem("language") || "zh-Hans";
localStorage.setItem("language", language);

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        let j = Math.floor(Math.random() * (i + 1));
        let temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
    return array;
}

let list = ["unrevealed", "unrevealed.owner", "rarity", "raritycolor"];
let globalDict = {};
list.forEach(element => fetch("https://www.sgkoishi.app/dbddata/static/" + element + ".json").then(r => r.json()).then(r => globalDict[element] = r));

function randomArray(min, max, length, isint) {
    return isint ? Array.from({
            length: length
        }, () => Math.floor(Math.random() * (max - min) + min)) :
        Array.from({
            length: length
        }, () => Math.random() * (max - min) + min);
}
let expWidth = 1200;
let expHeight = 1000;
let scene = new THREE.Scene();
let camera = new THREE.OrthographicCamera(0, 10, 0, 10, -5, 5);
let camera2 = new THREE.OrthographicCamera(10, 20, 1.5, -1.5, -2, 2);
let renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
});
renderer.setClearColor("rgb(255, 0, 0)", 0);
renderer.setSize(expWidth, expHeight);
document.getElementById("main").appendChild(renderer.domElement);
let mouse = new THREE.Vector2(-100, -100);
let floating = new THREE.Vector2(-600, -600);
let mouseDown = false;
let pureMouse = new THREE.Vector2(-100, -100);
let inCMouse = new THREE.Vector2(-100, -100);
let loader = new THREE.TextureLoader();
let ItemImg = loader.load("https://www.sgkoishi.app/dbddata/static/perks.png");
let materialPerk = new THREE.MeshLambertMaterial({
    map: ItemImg,
    transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest: false
});
let geometry = new THREE.PlaneGeometry(1, 1);
let blackBg = new THREE.Mesh(geometry);
blackBg.material.color.set(0);
blackBg.position.set(15, 0, 0);
blackBg.scale.set(10, 3, 1);
scene.add(blackBg);
let materialSmoke = new THREE.MeshLambertMaterial({
    map: loader.load("https://www.sgkoishi.app/dbd/smoke.png"),
    transparent: true,
    depthWrite: false,
    depthTest: false
});
materialSmoke.color.set("rgb(90, 40, 110)");
let meshSmokes = [];
for (let i = 0; i < 60; i++) {
    let meshSmoke = new THREE.Mesh(geometry, materialSmoke.clone());
    meshSmoke.userVX = (Math.random() * 8 + 2) / 240;
    meshSmoke.userBX = (Math.random() * 5) + 16;
    meshSmoke.userY = Math.random() * 3 - 1.5;
    meshSmoke.userRS = ((Math.random() * 2 - 1) * Math.PI) / 360;
    meshSmoke.position.set(Math.random() * 12 + 6, meshSmoke.userY, 0);
    meshSmoke.scale.set(4, 4, 4);
    meshSmokes.push(meshSmoke);
    scene.add(meshSmoke);
}
function makeText(t, font, width, height, textx, texty, fillstyle) {
    let bitmap = document.createElement('canvas');
    let g = bitmap.getContext('2d');
    bitmap.width = width;
    bitmap.height = height;
    g.font = font;
    g.fillStyle = fillstyle;
    g.fillText(t, textx, texty);
    let texture = new THREE.Texture(bitmap)
    texture.needsUpdate = true;
    return texture;
}
let textBg = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
    map: makeText("把最好的留到最后","Bold 72px Arial", 84*9, 84, 0, 70, "white"),
    transparent: true
}));
//blackBg.material.color.set(0);
textBg.position.set(15, 0, 0);
textBg.scale.set(9, 99 ** 99 == Math.pow(99, 99) ? 1 : -1, 1);
scene.add(textBg);
// https://www.sgkoishi.app/img/koishi.png
// https://www.sgkoishi.app/dbddata/static/perks.png
// https://www.sgkoishi.app/dbd/smoke.png

let meshItems = [];
let itemsName = "killerperks";
let params = (new URL(document.location)).searchParams;
if (params.get("q") != undefined)
{
    itemsName = params.get("q");
}
fetch("https://www.sgkoishi.app/dbddata/static/" + itemsName + ".json").then(r => r.json()).then(r => {
    let itemsShuffled = shuffleArray(r);
    for (let i = 0; i < itemsShuffled.length; i++)
    {
        let meshItem = new THREE.Mesh(geometry, materialPerk);
        meshItem.position.set(0.5 + (i % 10), 2.5 + parseInt(i / 10), 0);
        meshItem.rotation.y = Math.PI;
        meshItem.scale.set(1.25, -1.25, 1);
        meshItem.userItemCode = itemsShuffled[i];
        meshItems.push(meshItem);
        scene.add(meshItem);
    }
});
let light = new THREE.AmbientLight(0xffffff, 2); // soft white light
scene.add(light);
let now = Date.now();
let currentItem = "";
let forceUpdateF = false;
function animate() {
    requestAnimationFrame(animate);
    let xMatch = Math.abs(mouse.x % 1 - 0.5);
    let yMatch = Math.abs(mouse.y % 1 - 0.5);
    if (xMatch + yMatch < 0.5 && Math.abs(xMatch - yMatch) < 0.5)
    {
        let i = Math.round(Math.round(mouse.x - 0.5) + Math.round(mouse.y - 2.5) * 10);
        if (mouseDown) {
            if (!meshItems[i].userFetch) {
                meshItems[i].userFetch = true;
                let key = meshItems[i].userItemCode;
                fetch("https://www.sgkoishi.app/dbddata/" + key + "/owner.json").then(r => {
                    return r.json();
                }).then(r => {
                    globalDict[key + ".owner"] = r.owner;
                    let ownerCode = r.owner;
                    if (!globalDict[ownerCode]) {
                        fetch("https://www.sgkoishi.app/dbddata/" + ownerCode + "/data.json").then(r => {
                            return r.json();
                        }).then(r => {
                            globalDict[ownerCode] = r;
                        });
                    }
                }, e => {});
                fetch("https://www.sgkoishi.app/dbddata/" + key + "/rarity.json").then(r => {
                    return r.json();
                }).then(r => {
                    globalDict[key + ".rarity"] = r;
                });
                fetch("https://www.sgkoishi.app/dbddata/" + key + "/data.json").then(r => {
                    return r.json();
                }).then(r => {
                    globalDict[key] = r;
                    meshItems[i].shouldRotate = true;
                    meshItems[i].newTexture = loader.load("https://www.sgkoishi.app/dbddata/" + key + "/icon.png");
                }, (r) => {
                    console.log(r);
                });
            }
        } else {
		    if (forceUpdateF || (meshItems[i] !== undefined && meshItems[i].userItemCode !== currentItem)){
		        let ItemName = globalDict[meshItems[i].userItemCode];
				let rarityColor = globalDict["raritycolor"][0];
				let displayText = globalDict["unrevealed"][language];
			    if (ItemName) {
		            displayText = ItemName[language];
		            rarityColor = globalDict["raritycolor"][globalDict[meshItems[i].userItemCode + ".rarity"][1]];
			    }
		        textBg.material = new THREE.MeshLambertMaterial({
			        map: makeText(displayText, "Bold 72px Arial", 84 * 9, 84, 0, 70, "white"),
			        transparent: true
			    });
		        for (let i = 0; i < meshSmokes.length; i++) {
				    meshSmokes[i].material.color.set(rarityColor);
		        }
				forceUpdateF = false;
			}
		}
		if (i < meshItems.length) {
		    currentItem = meshItems[i].userItemCode;
		}
    }
    for (let i = 0; i < meshItems.length; i++) {
        let meshItem = meshItems[i];
        if (meshItem.shouldRotate) {
            if (meshItem.rotation.y < Math.PI * 1.5) {
                meshItem.rotation.y += Math.PI / 120;
            } else if (!meshItem.userDataInit) {
                meshItem.userDataInit = true;
				let colorRarity = globalDict["raritycolor"][globalDict[meshItem.userItemCode + ".rarity"][1]];
				forceUpdateF = true;
                meshItem.material = new THREE.ShaderMaterial({
    vertexShader: `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`,
    fragmentShader: `
uniform sampler2D textureA;
uniform sampler2D textureB;
uniform vec3 color;
uniform vec3 ItemRarity;
varying vec2 vUv;
void main() {
    vec3 c;
    vec2 scaledvuv = vUv;
    scaledvuv -= vec2(0.5);
    scaledvuv = mat2(1.8, 0.0, 0.0, 1.8) * scaledvuv;
    scaledvuv += vec2(0.5);
    scaledvuv.x -= 0.025;
    vec4 Ca = texture2D(textureA, vUv);
	Ca.rgb *= mat3(ItemRarity.r, 0, 0, 0, ItemRarity.g, 0, 0, 0, ItemRarity.b);
    vec4 Cb = texture2D(textureB, scaledvuv);
    c = Cb.rgb * Cb.a + Ca.rgb * Ca.a * (1.0 - Cb.a);
    gl_FragColor= vec4(c, 1.0);
    if (Ca.a < 0.5) 
    {
        gl_FragColor.a = 0.0;
    }
}`,
    uniforms: {
        textureA: { type: "t", value: ItemImg },
        textureB: { type: "t", value: meshItem.newTexture },
		ItemRarity: { value: new THREE.Color(colorRarity) }
    },
	transparent: true,
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest: false
});
            } else if (meshItem.rotation.y < Math.PI * 2) {
                meshItem.rotation.y += Math.PI / 120;
            }
        }
    }
    for (let i = 0; i < meshSmokes.length; i++) {
        meshSmokes[i].position.x += meshSmokes[i].userVX;
        if (meshSmokes[i].position.x > meshSmokes[i].userBX) {
            meshSmokes[i].position.x = 8;
            meshSmokes[i].material.opacity = 1;
        } else {
            meshSmokes[i].material.opacity = 1 - (meshSmokes[i].position.x - 9) / (meshSmokes[i].userBX - 8);
        }
        meshSmokes[i].rotation.z += meshSmokes[i].userRS;
    }
    renderer.setViewport(0, 0, expWidth, expWidth);
    renderer.setScissor(0, 0, expWidth, expHeight);
    renderer.setScissorTest(true);
    renderer.render(scene, camera);
    renderer.autoClear = false;
    renderer.setViewport(floating.x, floating.y, 500, 150);
    renderer.setScissor(floating.x, floating.y, 500, 150);
    renderer.setScissorTest(true);
    renderer.render(scene, camera2);
    renderer.autoClear = true;
    renderer.setClearColor("rgb(64, 64, 64)", 1);
}

function updateMouse() {
    mouse.x = ((pureMouse.x - document.getElementById("main").getBoundingClientRect().x) / Math.min(expWidth, window.innerWidth)) * 10;
    mouse.y = ((pureMouse.y - document.getElementById("main").getBoundingClientRect().y) / Math.min(expHeight, window.innerHeight)) * 8.35 + 1.65;
    floating.x = pureMouse.x - document.getElementById("main").getBoundingClientRect().x;
    if (floating.x < 0) floating.x = 0;
    else if (floating.x > expWidth) floating.x = 700;
    else if (floating.x + 500 > expWidth) floating.x -= 500;
    floating.y = expHeight - pureMouse.y + document.getElementById("main").getBoundingClientRect().y - 150;
    if (floating.y < 0) floating.y += 150;
}
window.addEventListener('mousemove', (event) => {
    pureMouse.x = event.clientX
    pureMouse.y = event.clientY;
    updateMouse();
}, false);
window.addEventListener('scroll', updateMouse, false);
window.addEventListener("mousedown", () => mouseDown = true);
window.addEventListener("mouseup", () => mouseDown = false);
animate();
</script>

</html>